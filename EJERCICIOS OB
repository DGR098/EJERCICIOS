import jdk.jshell.spi.ExecutionControl;

import javax.swing.event.InternalFrameAdapter;
import java.io.*;
import java.lang.reflect.Array;
import java.nio.file.Path;
import java.util.*;

import static jdk.jpackage.internal.IOUtils.copyFile;


public class Reverso {

// EJERCICIO 1
    public static String reverse(String texto) {
        StringBuilder reversedText = new StringBuilder();
        for (int i = texto.length() - 1; i >= 0; i--) {
            reversedText.append(texto.charAt(i));
        }
        return reversedText.toString();
    }


    public static void main(String[] args) {

        String texto = "hola mundo";
        String textoInvertido = reverse(texto);
        System.out.println(textoInvertido);

    }

    public static void main(String[] args) {

        // EJERCICIO 2
        String[] uno = {"CERO", "UNO"};

        for (int i = 0; i < uno.length; i++) {
            System.out.println("Posicion del array " + i + " contiene el valor " + uno[i]);
        }

        // EJERCICIO 3
        int[][] enteros = new int[2][2];
        enteros[0][0] = 1;
        enteros[0][1] = 2;

        enteros[1][0] = 10;
        enteros[1][1] = 20;

        for (int i = 0; i < enteros.length; i++) {
            for (int j = 0; j < enteros[i].length; j++) {
                System.out.println("Posición: [" + i + "][" + j + "] y contiene el valor " + enteros[i][j]);
            }
        }

        // EJERCICIO 4
        Vector<Integer> bector = new Vector<>();

        bector.add(1);
        bector.add(2);
        bector.add(3);
        bector.add(4);
        bector.add(5);

        bector.remove(1);
        bector.remove(1);

        System.out.println("EL vector ahora es: " + bector);

        // EJERCICIO 5

        // el problema de utilizar un Vector con la capcidad por defecto de 1000 elementos
        // Es que estariamos utilizando mas memoria de la necesaria,
        // ya que el vector aumenta su capacidad de 10 en 10, y eso afectaria al rendimiento del programa


        // EJERCICIO 6
        ArrayList<String> lista = new ArrayList<>();
        lista.add("Uno");
        lista.add("Dos");
        lista.add("Tres");
        lista.add("Cuatro");

        LinkedList<String> listaEnlazada = new LinkedList<>(lista);

        for (String elemento : listaEnlazada) {
            System.out.println("Elemento actual en la lista enlazada: " + elemento);
        }

        // EJERCICIO 7
        ArrayList<Integer> numeros = new ArrayList<>();


        for (int i = 0; i < 11; i++) {
            numeros.add(i);
            }
        // Eliminar los números pares del ArrayList
        Iterator<Integer> iter = numeros.iterator();
        while (iter.hasNext()) {
            int numero = iter.next();
            if (numero % 2 == 0) {
                iter.remove();
            }
        }

        for (int numero : numeros) {
            System.out.println(numero);
        }

        // EJERCICIO 8


        Scanner scanner = new Scanner(System.in);
        System.out.print("Introduce dos números: ");

        int numero1 = scanner.nextInt();
        int numero2 = scanner.nextInt();

        try {
            int resultado = numero1 / numero2;
            System.out.println("El resultado es: " + resultado);
        } catch (ArithmeticException e) {
            System.out.println("¡No se puede dividir por cero!");
        }

        try {
            InputStream fileIn = new FileInputStream("/etc/passwd");

            try {
                byte[] datos = fileIn.readAllBytes();
                for (byte dato : datos) {
                    System.out.print((char) dato);
                }
                fileIn.close();

            } catch (IOException e) {
                System.out.println("No puedo leerlo: " + e.getMessage());
            }
        } catch (FileNotFoundException e) {
            System.out.println("Fichero no encontrado: " + e.getMessage());
        }


        // EJERCICIO 9

        public static void copyFile (String fileIn; String fileOut){
            try (InputStream inputStream = new FileInputStream(fileIn);
                 PrintStream printStream = new PrintStream(new FileOutputStream(fileOut))) {
                byte[] buffer = new byte[10];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    printStream.write(buffer, 0, bytesRead);
                }
                System.out.println("Archivo copiado exitosamente.");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


        public static void main(String[] args) {
            String fileIn = "Desktop\\Nuevo Text Document (2).txt";
            String fileOut = "Desktop\\Nuevo Text Document (3).txt";
            copyFile(Path.of(fileIn), Path.of(fileOut));
        }

        // EJERCICIO 10


        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            PrintStream printStream = new PrintStream(System.out);
            Map<String, List<String>> dataStorage = new HashMap<>();

            while (true) {
                printStream.println("Ingrese una clave (o 'salir' para terminar):");
                String key = reader.readLine();

                if (key.equalsIgnoreCase("salir")) {
                    break;
                }

                printStream.println("Ingrese un valor:");
                String value = reader.readLine();

                List<String> values = dataStorage.getOrDefault(key, new ArrayList<>());
                values.add(value);
                dataStorage.put(key, values);
            }

            printStream.println("Datos almacenados:");
            for (Map.Entry<String, List<String>> entry : dataStorage.entrySet()) {
                String key = entry.getKey();
                List<String> values = entry.getValue();
                printStream.println("Clave: " + key);
                printStream.println("Valores:");
                for (String value : values) {
                    printStream.println("- " + value);
                }
                printStream.println();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }

        }
}
